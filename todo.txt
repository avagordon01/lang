bugfix break, continue instructions dont actually get compiled to assembly from IR
    what
    if you compile the IR manually with llc then assembler it works...
    either my invocation of passes is wrong
    or its a bug in llvm assembly output
    what
    llc, clang and everything else uses legacy
    no examples of using modern passmanager and cant find a way to emit machine code

    could narrow down the difference between my invocation and theirs
    or just invoke their command line
        could get nice CLI for free, and possibly optimisation etc
    would it stop us from compiling fine-grained modules for different targets? CPU/GPU?
errors
    add location information to the ast
    print out the location information for errors
codegen
    casts/conversions from one type to another
    builtins for math and bitwise operations
memory
    no aliasing
    everything is reachable from the stack?
    unique_ptr
    dag or tree?
    initialisation?
    no declaration without definition/initialisation
modules
    import
        import exported functions from another file
        to typecheck and generate calls to external functions
    generate c header
    top-level definition order unimportant
aggregate types
    arrays, structs, vectors
    getelementptr
    multiple return? tuples
make if, for, while expressions not statements
    break should be able to return values
add switch-case statements

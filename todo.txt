bugfix break, continue instructions dont actually get compiled to assembly from IR
    what
    if you compile the IR manually with llc then assembler it works...
    either my invocation of passes is wrong
    or its a bug in llvm assembly output
    what
    llc, clang and everything else uses legacy
    no examples of using modern passmanager and cant find a way to emit machine code

    could narrow down the difference between my invocation and theirs
    or just invoke their command line
        could get nice CLI for free, and possibly optimisation etc
    would it stop us from compiling fine-grained modules for different targets? CPU/GPU?
errors
    add location information to the ast
    print out the location information for errors
codegen
    casts/conversions from one type to another
    builtins for math and bitwise operations
memory
    no aliasing
    everything is reachable from the stack?
    unique_ptr
    dag or tree?
    initialisation?
    no declaration without definition/initialisation
modules
    import
        import exported functions from another file
        to typecheck and generate calls to external functions
    generate c header
    top-level definition order unimportant
aggregate types
    arrays, structs, vectors
    getelementptr
    multiple return? tuples
make if, switch, for, while, block expressions not statements
    todo type inference for if etc

    loop break should optionally return a value
    if the last statement in a block is an expression its value should be returned

    loop return removes the need for some other less nice constructs
        python-like for/else
        multi level break
    switch continue should fallthrough

    not sure what for and while should return yet
    maybe vector or iterator like rust or python
